import json
import os
import re
import sys
from pathlib import Path

# plt.style.use("custom_standard")
# plt.style.use("custom_small")
import numpy as np
import pandas as pd
from Bio import Align, AlignIO, Seq, SeqIO

import local_seqtools.cider_tools as cider_tools
import local_seqtools.general_utils as tools

# import matplotlib.pyplot as plt


def aln_gaps_mask(aln, gap_frac_cutoff=0.20):
    """returns a mask of positions in alignment with less than gap_perc_cutoff gaps"""
    gap_frac_list = []
    alignment_width = aln.get_alignment_length()
    n_seqs_in_aln = len(aln)
    for i in range(alignment_width):
        gap_count = aln[:, i].count("-")
        gap_frac = gap_count / n_seqs_in_aln
        gap_frac_list.append(gap_frac)
    return np.array(gap_frac_list) < gap_frac_cutoff


def add_seq_gap_mask_to_mask(
    score_list_seq_str: str,
    gappy_mask: np.ndarray,
):
    master_mask = []
    for s, m in zip(score_list_seq_str, gappy_mask):
        if s == "-":
            master_mask.append(False)
        else:
            master_mask.append(m)
    return master_mask


def make_score_mask(alignment, query_seq_str, gap_frac_cutoff=0.20):
    gap_mask = aln_gaps_mask(
        alignment,
        gap_frac_cutoff=gap_frac_cutoff,
    )
    score_mask = add_seq_gap_mask_to_mask(
        query_seq_str,
        gap_mask,
    )
    return gap_mask, score_mask


def pad_hit_sequence(hit_sequence: str, query_sequence: str, target_hit_length=36):
    s_i = query_sequence.find(hit_sequence)
    s_e = s_i + len(hit_sequence)
    flank = round((target_hit_length - len(hit_sequence)) / 2)
    s_i_new = max(0, s_i - flank)
    s_e_new = min(len(query_sequence), s_e + flank)
    return query_sequence[s_i_new:s_e_new]


class og_level_odb_json:
    '''
    This class is for reading the json files generated by the main odb run scripts (`src/local_orthoDB_tools`)
    '''
    def __init__(self, json_filepath):
        self.json_filepath = Path(json_filepath)
        with open(self.json_filepath, "r") as f:
            self.info_dict = json.load(f)

        # add every key in the info_dict as an attribute of the class
        # not sure if this is a good idea or not (probably not)
        # self.__dict__.update(self.info_dict)
        # above command added the below attributes but I might want to select
        # the individual attributes instead at some point (i.e. remove the above line)
        # so I'm assigning them explicitly here as well
        self.query_gene_id = self.info_dict["query_gene_id"]
        self.query_sequence_str = self.info_dict["query_sequence_str"]
        self.query_sequence_id_str = self.info_dict["query_sequence_id_str"]
        self.level = self.info_dict["selected_query_og_level_name"]
        self.query_uniprot_name = None
        self.output_file_dict = self.info_dict["output_file_dict"]
        self.num_sequences_LDO_cdhit = self.info_dict["num_sequences_LDO_cdhit"]

        for k, v in self.output_file_dict.items():
            self.output_file_dict[k] = Path(v).name

        parent_folder = self.json_filepath.parent
        self.parent_folder = parent_folder

        self.sequence_files = {k: str(parent_folder / v) for k, v in self.output_file_dict.items() if 'json' not in k}

        self.sequences_full_OG = tools.import_fasta(
            os.path.join(
                parent_folder, self.output_file_dict["fasta sequences - full OG"]
            )
        )
        self.sequences_LDOs = tools.import_fasta(
            os.path.join(
                parent_folder, self.output_file_dict["fasta sequences - OG LDOs"]
            )
        )
        self.sequences_orthologs_ldo_clustered = tools.import_fasta(
            os.path.join(
                parent_folder, self.output_file_dict["fasta sequences - OG LDOs cdhit"]
            )
        )
        self.alignment_orthologs_ldo_clustered = AlignIO.read(
            os.path.join(
                parent_folder, self.output_file_dict["fasta alignment - OG LDO cdhit"]
            ),
            "fasta",
        )

        try:
            self.query_sequence = [
                i
                for i in self.sequences_orthologs_ldo_clustered
                if self.query_sequence_id_str in i.id
            ][0]
        except IndexError as e:
            raise IndexError(f'query sequence {self.query_sequence_id_str} not found in final orthogroup sequences. {self.json_filepath}') from e
        self.query_aligned_sequence = [
            i
            for i in self.alignment_orthologs_ldo_clustered
            if self.query_sequence_id_str in i.id
        ][0]
        _, self.alignment_index_key = tools.reindex_alignment(
            self.query_aligned_sequence
        )


class hit_sequence_class(og_level_odb_json):
    
    def __init__(self, json_filepath):
        super().__init__(json_filepath)
        self.scores = None
        self.z_score_dict = None
        self.scores_dict = None
    
    # def create_alignment_score_mask(self, gap_frac_cutoff=0.20):
    #     self.gap_mask_frac_cutoff = gap_frac_cutoff
    #     self.gap_mask, self.score_mask = make_score_mask(
    #         self.alignment_orthologs_ldo_clustered,
    #         str(self.query_aligned_sequence.seq),
    #         gap_frac_cutoff=gap_frac_cutoff,
    #     )

    def __str__(self):
        return f'orthogroup level/file: {self.json_filepath}\nlevel: {self.level}\nhit sequence: {self.hit_sequence}'

    @staticmethod
    def pad_hit_sequence(hit_sequence: str, query_sequence: str, target_hit_length=36):
        if len(hit_sequence) >= target_hit_length:
            return hit_sequence
        s_i = query_sequence.find(hit_sequence)
        if s_i<0:
            raise ValueError(f'hit sequence {hit_sequence} not found in query sequence {query_sequence}')
        s_e = s_i + len(hit_sequence) # I think that this is now inclusive
        flank = round((target_hit_length - len(hit_sequence)) / 2)
        s_i_new = max(0, s_i - flank)
        s_e_new = min(len(query_sequence), s_e + flank)
        return query_sequence[s_i_new:s_e_new]

    @staticmethod
    def hit_in_query_bool(hit_sequence: str, query_sequence: str):
        return hit_sequence in query_sequence

    def find_query_hit_sequence_in_alignment(self, subsequence: str, padding_target_length: int=0):
        # TODO: add a check to make sure the subsequence is not found in multiple places in the query sequence
        # TODO: calculate conservation for the entire sequence first
        self.found_hit = self.hit_in_query_bool(subsequence, self.query_sequence_str)
        if not self.found_hit:
            self.hit_start_position = -1
            self.hit_end_position = -1
            self.hit_alignment_start_position = -1
            self.hit_alignment_end_position = -1
            return
        if padding_target_length > 0:
            subsequence = self.pad_hit_sequence(subsequence, self.query_sequence_str, target_hit_length=padding_target_length)
        self.hit_sequence = subsequence
        hit_start_position = self.query_sequence.seq.find(self.hit_sequence)
        hit_end_position = hit_start_position + len(self.hit_sequence) - 1
        hit_alignment_start_position = self.alignment_index_key[hit_start_position]
        hit_alignment_end_position = self.alignment_index_key[hit_end_position]
        self.hit_start_position = hit_start_position
        self.hit_end_position = hit_end_position
        self.hit_alignment_start_position = hit_alignment_start_position
        self.hit_alignment_end_position = hit_alignment_end_position

    def _slice_alignment(
        self,
        slice_start_position=None,
        slice_end_position=None,
    ):
        """
        Parameters
        ----------
        slice_start_position : int, optional
            start position of alignment slice. If not provided, the function uses `self.hit_alignment_start_position`. by default None
        slice_end_position : int, optional
            end position of alignment slice. If not provided, the function uses `self.hit_alignment_end_position+1`, by default None
        """
        if slice_start_position is None:
            slice_start_position = self.hit_alignment_start_position
        if slice_end_position is None:
            slice_end_position = self.hit_alignment_end_position + 1
        self.alignment_slice = self.alignment_orthologs_ldo_clustered[
            :, slice_start_position:slice_end_position
        ]
        self.hit_sequence_in_alignment = [
            i for i in self.alignment_slice if self.query_sequence.id in i.id
        ][0]

    def hit_idr_characterization(self, cider=True):
        # cols = ["hit sequence in idr", "IDR start", "IDR end", "IDR length"]
        d = {}
        d["hit sequence in idr"] = False
        if self.found_hit:
            for region in self.info_dict["idr_regions"]:
                # (self.hit_start_position - len(self.hit_sequence))
                if (
                    self.hit_start_position >= region[0]
                    and self.hit_end_position <= region[1]
                ):
                    d["hit sequence in idr"] = True
                    idr = region
        if d["hit sequence in idr"]:
            d["IDR start"] = idr[0]
            d["IDR end"] = idr[1]
            d["IDR length"] = idr[1] - idr[0]
            idr_query_sequence_str = str(self.query_sequence[idr[0] : idr[1]].seq)
            if cider:
                d.update(cider_tools.get_local_cider_features(idr_query_sequence_str))
            
            idr_aln_start = self.alignment_index_key[d["IDR start"]]
            idr_aln_end = self.alignment_index_key[d["IDR end"]]
            # idr_aln_start, idr_aln_end = tools.indexes2alignmentindexes(
                # d["IDR start"], d["IDR end"], self.alignment_index_key
            # )
            idr_query_aligned_sequence = self.query_aligned_sequence[
                idr_aln_start:idr_aln_end
            ]
            idr_alignment_slice = self.alignment_orthologs_ldo_clustered[
                :, idr_aln_start:idr_aln_end
            ]
            d["IDR aln start"] = idr_aln_start
            d["IDR aln end"] = idr_aln_end
            self.idr_query_aligned_sequence = idr_query_aligned_sequence
            self.idr_alignment_slice = idr_alignment_slice
            self.idr_length = d["IDR length"]
            self.idr_query_sequence_str = idr_query_sequence_str
            self.idr_aln_start = idr_aln_start
            self.idr_aln_end = idr_aln_end
            self.idr_start = d["IDR start"]
            self.idr_end = d["IDR end"]
        self.hit_in_idr = d["hit sequence in idr"]
        self.idr_info_dict = d
        return d

    def add_attributes2dict(self, d):
        d['level']=self.level
        d['parent_folder']=str(self.parent_folder)
        d['sequence_files']=self.sequence_files
        d['query_gene_id']=self.query_gene_id
        d['query_sequence_id_str']=self.query_sequence_id_str
        d['query_sequence_str']=self.query_sequence_str
        d['query_aligned_sequence']=str(self.query_aligned_sequence.seq)
        d["hit_sequence"] = self.hit_sequence
        d['found_hit'] = self.found_hit
        d["hit_start_position"] = self.hit_start_position
        d["hit_end_position"] = self.hit_end_position
        d["hit_alignment_start_position"] = self.hit_alignment_start_position
        d["hit_alignment_end_position"] = self.hit_alignment_end_position
        d["hit_in_idr"] = self.hit_in_idr
        if self.hit_in_idr:
            d["idr_info_dict"] = self.idr_info_dict
            d['idr_start']=self.idr_start
            d['idr_end']=self.idr_end
            # d['idr_query_sequence_str']=self.idr_query_sequence_str
            d['idr_aln_start']=self.idr_aln_start
            d['idr_aln_end']=self.idr_aln_end
            # d['idr_query_aligned_sequence']=str(self.idr_query_aligned_sequence.seq)
        # d['alignment_index_key']=self.alignment_index_key
        return d


def prep_og_hit_class_from_leveljson(
        og_json_file,
        hit_sequence,
        target_hit_length=36,
        cider=False
    ):
    ogseqs_o = hit_sequence_class(
        og_json_file
    )
    ogseqs_o.find_query_hit_sequence_in_alignment(
        hit_sequence,
        padding_target_length=target_hit_length
    )
    if not ogseqs_o.found_hit:
        return False
    ogseqs_o.hit_idr_characterization(cider=cider)
    ogseqs_o._slice_alignment()
    return ogseqs_o


class hit_sequence_class_given_hit_positions(og_level_odb_json):
    
    def __init__(self, json_filepath, hit_start_position, hit_end_position):
        super().__init__(json_filepath)
        self.hit_sequence = self.query_sequence_str[hit_start_position:hit_end_position+1]
        self.found_hit = self.hit_in_query_bool(
            self.hit_sequence,
            self.query_sequence_str
        )
        self.hit_start_position = int(hit_start_position)
        self.hit_end_position = int(hit_end_position)
        self.hit_alignment_start_position = self.alignment_index_key[hit_start_position]
        self.hit_alignment_end_position = self.alignment_index_key[hit_end_position]
        self.is_hit_in_idr()


    def is_hit_in_idr(self):
        self.hit_in_idr = False
        for region in self.info_dict["idr_regions"]:
            if self.hit_start_position >= region[0] and self.hit_end_position <= region[1]:
                self.hit_in_idr = True
                idr = region
        if self.hit_in_idr:
            self.idr_start = idr[0]
            self.idr_end = idr[1]
            self.idr_aln_start = self.alignment_index_key[idr[0]]
            self.idr_aln_end = self.alignment_index_key[idr[1]]
        else:
            self.idr_start = None
            self.idr_end = None
            self.idr_aln_start = None
            self.idr_aln_end = None

    @staticmethod
    def hit_in_query_bool(hit_sequence: str, query_sequence: str):
        return hit_sequence in query_sequence

    def get_attributes_as_dict(self):
        d = {}
        d['level']=self.level
        d["num_sequences_LDO_cdhit"]=self.info_dict["num_sequences_LDO_cdhit"]
        d["selected_query_ogid"]=self.info_dict["selected_query_ogid"]
        d['sequence_files']=self.sequence_files
        d['query_sequence_id_str']=self.query_sequence_id_str
        d['query_sequence_str']=self.query_sequence_str
        d['query_aligned_sequence']=str(self.query_aligned_sequence.seq)
        d["hit_sequence"] = self.hit_sequence
        d['found_hit'] = self.found_hit
        d["hit_start_position"] = self.hit_start_position
        d["hit_end_position"] = self.hit_end_position
        d["hit_alignment_start_position"] = self.hit_alignment_start_position
        d["hit_alignment_end_position"] = self.hit_alignment_end_position
        d["hit_in_idr"] = self.hit_in_idr
        if self.hit_in_idr:
            d['idr_start']=self.idr_start
            d['idr_end']=self.idr_end
            d['idr_aln_start']=self.idr_aln_start
            d['idr_aln_end']=self.idr_aln_end
        return d




# find all occurences of a string in a string
def find_all(string: str, substring):
    start = 0
    while True:
        start = string.find(substring, start)
        if start == -1: return
        yield start
        start += len(substring)

## search for the hit sequence in the odb sequence and return the start and end positions
def find_hit_in_odb_seq(hit_seq, odb_seq):
    match_positions = list(find_all(odb_seq, hit_seq))
    if len(match_positions) == 0:
        print(f'could not find {hit_seq} in {odb_seq}')
        return False
    elif len(match_positions) > 1:
        raise ValueError(f'found more than one match for {hit_seq} in {odb_seq}')
    elif len(match_positions) == 1:
        return match_positions[0], match_positions[0]+len(hit_seq)-1
